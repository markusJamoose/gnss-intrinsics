/*!
 *  \file avx512_intrinsics.h
 *  \brief      Provides c functions that implement Intel's AVX512 intrinsic
 * functions \details    Based off Volk kernel functions. Specifically the AVX
 * functions defined in: volk_32f_x2_multiply_32f.h volk_32f_accumulator_s32f.h
 * The files can be found at:
 *   https://github.com/gnuradio/volk/blob/master/kernels/volk/volk_32f_x2_multiply_32f.h
 *   https://github.com/gnuradio/volk/blob/master/kernels/volk/volk_32f_accumulator_s32f.h
 *  \author    Jake Johnson
 *  \version   4.1a
 *  \date      Jan 23, 2018
 *  \pre       Make sure you have .bin files containing data and lookup tables
 *  \bug       None reported
 *  \warning   None so far
 *  \copyright TBD
 */

/*
 * This file provides c functions that implement Intel's AVX512 intrinsic
 * functions
 *
 * Author: Jake
 * Date Created: Jan 23, 2018
 * Last Modified:  Jan 29, 2018
 *
 * Based off Volk kernel functions. Specifically the AVX functions defined in:
 *   volk_32f_x2_multiply_32f.h
 *   volk_32f_accumulator_s32f.h
 * The files can be found at:
 *   https://github.com/gnuradio/volk/blob/master/kernels/volk/volk_32f_x2_multiply_32f.h
 *   https://github.com/gnuradio/volk/blob/master/kernels/volk/volk_32f_accumulator_s32f.h
 *
 */

#include "immintrin.h"
#include <math.h>
#include <stdio.h>

/*!
 *  \brief Generates a NCO based on the direct lookup table approach with SIMD
 * intrinsic and generates the carrier as fl32 type.
 *  \param[out] sig_nco Sinusoidal wave generated byt the NCO
 *  \param[in] lut Lookup table to be use for the code
 *  \param[in] blk_size Total number of elements in the sig_nco vector
 *  \param[in] rem_carr_phase Carrier phase remainder of the sinusoidal wave
 *  \param[in] carr_freq Carrier frequency of the sinusoidal wave
 *  \param[in] samp_freq Sampling frequency of the signal to be generated
 */
void avx512_nco_fl32(float *sig_nco, const float *lut, const int blk_size,
                     const double rem_carr_phase, const double carr_freq,
                     const double samp_freq) {
  int inda;
  const unsigned int sixteenth_points = blk_size / 16;
  const unsigned int nom_carr_step =
      (unsigned int)(carr_freq * (4294967296.0 / samp_freq) + 0.5);

  // Declarations for serial implementation
  unsigned int nom_carr_phase_base =
      (unsigned int)(rem_carr_phase * (4294967296.0 / (2.0 * M_PI)) + 0.5);
  unsigned int nom_carr_idx = 0;

  // Important variable declarations
  __m512i carr_phase_base = _mm512_set1_epi32(nom_carr_phase_base);
  __m512i carr_step_base = _mm512_set_epi32(
      15 * nom_carr_step, 14 * nom_carr_step, 13 * nom_carr_step,
      12 * nom_carr_step, 11 * nom_carr_step, 10 * nom_carr_step,
      9 * nom_carr_step, 8 * nom_carr_step, 7 * nom_carr_step,
      6 * nom_carr_step, 5 * nom_carr_step, 4 * nom_carr_step,
      3 * nom_carr_step, 2 * nom_carr_step, 1 * nom_carr_step,
      0 * nom_carr_step);
  __m512i carr_idx = _mm512_set1_epi32(0);
  __m512i hex_ff = _mm512_set1_epi32(0xFF);
  __m512 nco;
  __m512i carr_step_offset = _mm512_set1_epi32(16 * nom_carr_step);
  __m256i phase_base;

  // First iteration happens outside the loop
  carr_phase_base = _mm512_add_epi32(carr_phase_base, carr_step_base);

  for (inda = 0; inda < sixteenth_points; inda++) {
    // Obtain integer index in 8:24 number
    carr_idx = _mm512_srli_epi32(carr_phase_base, 24);
    carr_idx = _mm512_and_si512(carr_idx, hex_ff);

    // Look in lut
    nco = _mm512_i32gather_ps(carr_idx, lut, 4);

    // Delta step
    // carr_step_base = _mm256_add_epi32(carr_step_base, carr_step_offset);
    carr_phase_base = _mm512_add_epi32(carr_phase_base, carr_step_offset);

    // 5- Store values in output buffer
    _mm512_storeu_ps((float *)sig_nco, nco);

    // 6- Update pointers
    sig_nco += 16;
  }

  inda = sixteenth_points * 16;
  phase_base = _mm512_extracti32x8_epi32(carr_phase_base, 1);
  nom_carr_phase_base = (unsigned int)_mm256_extract_epi32(phase_base, 7);

  // generate buffer of output
  for (; inda < blk_size; ++inda) {
    // Obtain integer index in 8:24 number
    nom_carr_idx = (nom_carr_phase_base >> 24) & 0xFF;
    // Look in lut
    *sig_nco++ = lut[nom_carr_idx]; // get sample value from LUT
    // Delta step
    nom_carr_phase_base += nom_carr_step;
  }
}

/*!
 *  \brief Generates a nominal NCO based on the direct lookup table approach as
 * fl32 type
 *  \param[out] sig_nco Sinusoidal wave generated byt the NCO
 *  \param[in] lut Lookup table to be use for the code
 *  \param[in] blk_size Total number of elements in the sig_nco vector
 *  \param[in] rem_carr_phase Carrier phase remainder of the sinusoidal wave
 *  \param[in] carr_freq Carrier frequency of the sinusoidal wave
 *  \param[in] samp_freq Sampling frequency of the signal to be generated
 */
void avx512_nom_nco_fl32(float *sig_nco, const float *LUT, const int blksize,
                         const double remCarrPhase, const double carrFreq,
                         const double sampFreq) {

  unsigned int carrPhaseBase =
      (remCarrPhase * (4294967296.0 / (2.0 * M_PI)) + 0.5);
  unsigned int carrStep = (carrFreq * (4294967296.0 / sampFreq) + 0.5);
  unsigned int carrIndex = 0;
  int inda;

  // Store this values for debug purposes only
  unsigned int carrPhaseBaseVec[blksize];
  unsigned int carrIndexVec[blksize];

  // for each sample
  for (inda = 0; inda < blksize; ++inda) {
    // Obtain integer index in 8:24 number
    carrIndexVec[inda] = carrIndex;
    carrIndex = (carrPhaseBase >> 24) & 0xFF;

    // Look in lut
    sig_nco[inda] = LUT[carrIndex];

    // Delta step
    carrPhaseBaseVec[inda] = carrPhaseBase;
    carrPhaseBase += carrStep;
  }
}

/*!
 *  \brief Generates an Early, Late and Propmt CA code based on the direct
 * lookup table approach
 * \param[out] ecode Early CA code
 * \param[out] pcode Prompt CA code
 * \param[out] lcode Late CA code
 * \param[in] lut Lookup table to be use for the code
 * \param[in] blk_size Total number of elements in the sig_nco vector
 * \param[in] rem_code_phase Carrier phase remainder of the sinusoidal wave
 * \param[in] code_freq Carrier frequency of the sinusoidal wave
 * \param[in] samp_freq Sampling frequency of the signal to be generated
 */
void avx512_nom_code_fl32(float *ecode, float *pcode, float *lcode,
                          const float *cacode, const int blksize,
                          const double remCodePhase, const double codeFreq,
                          const double sampFreq) {

  int inda;
  double earlyLateSpc = 0.5;
  double codePhaseStep = codeFreq / sampFreq;
  double baseCode;
  int pCodeIdx, eCodeIdx, lCodeIdx;

  // for each sample
  for (inda = 0; inda < blksize; ++inda) {
    baseCode = (inda * codePhaseStep + remCodePhase);
    pCodeIdx = (float)(baseCode) < baseCode ? (baseCode + 1) : baseCode;
    eCodeIdx = (float)(baseCode - earlyLateSpc) < (baseCode - earlyLateSpc)
                   ? (baseCode - earlyLateSpc + 1)
                   : (baseCode - earlyLateSpc);
    lCodeIdx = (float)(baseCode + earlyLateSpc) < (baseCode + earlyLateSpc)
                   ? (baseCode + earlyLateSpc + 1)
                   : (baseCode + earlyLateSpc);

    ecode[inda] = *(cacode + eCodeIdx);
    pcode[inda] = *(cacode + pCodeIdx);
    lcode[inda] = *(cacode + lCodeIdx);
  }
}

/*!
 *  \brief Generates an Early, Late and Propmt CA code based on the direct
 * lookup table approach with SIMD instructions
 *  \param[out] ecode Early CA code
 *  \param[out] pcode Prompt CA code
 *  \param[out] lcode Late CA code
 *  \param[in] lut Lookup table to be use for the code
 *  \param[in] blk_size Total number of elements in the sig_nco vector
 *  \param[in] rem_code_phase Carrier phase remainder of the sinusoidal wave
 *  \param[in] code_freq Carrier frequency of the sinusoidal wave
 *  \param[in] samp_freq Sampling frequency of the signal to be generated
 */
void avx512_code_fl32(float *ecode, float *pcode, float *lcode,
                      const float *cacode, const int blksize,
                      const float remCodePhase, const float codeFreq,
                      const float sampFreq) {

  int inda;
  const unsigned int sixteenth_points = blksize / 16;
  float earlyLateSpc = 0.5;
  float codePhaseStep = codeFreq / sampFreq;
  float baseCode;
  int pCodeIdx, eCodeIdx, lCodeIdx;

  // Important variable declarations
  __m512 ecode_phase_base = _mm512_set1_ps(remCodePhase - earlyLateSpc + 0.5);
  __m512 pcode_phase_base = _mm512_set1_ps(remCodePhase + 0.5);
  __m512 lcode_phase_base = _mm512_set1_ps(remCodePhase + earlyLateSpc + 0.5);

  __m512 code_step_base =
      _mm512_set_ps(15 * codePhaseStep, 14 * codePhaseStep, 12 * codePhaseStep,
                    12 * codePhaseStep, 11 * codePhaseStep, 10 * codePhaseStep,
                    9 * codePhaseStep, 8 * codePhaseStep, 7 * codePhaseStep,
                    6 * codePhaseStep, 5 * codePhaseStep, 4 * codePhaseStep,
                    3 * codePhaseStep, 2 * codePhaseStep, 1 * codePhaseStep,
                    0 * codePhaseStep);
  __m512i ecode_idx = _mm512_set1_epi32(0);
  __m512i pcode_idx = _mm512_set1_epi32(0);
  __m512i lcode_idx = _mm512_set1_epi32(0);

  __m512 elut, plut, llut;
  __m512 code_step_offset = _mm512_set1_ps(8 * codePhaseStep);

  // First iteration happens outside the loop
  ecode_phase_base = _mm512_add_ps(ecode_phase_base, code_step_base);
  pcode_phase_base = _mm512_add_ps(pcode_phase_base, code_step_base);
  lcode_phase_base = _mm512_add_ps(lcode_phase_base, code_step_base);

  for (inda = 0; inda < sixteenth_points; inda++) {
    // Obtain integer index in 8:24 number
    ecode_idx = _mm512_cvtps_epi32(ecode_phase_base);
    pcode_idx = _mm512_cvtps_epi32(pcode_phase_base);
    lcode_idx = _mm512_cvtps_epi32(lcode_phase_base);

    // Look in lut
    elut = _mm512_i32gather_ps(ecode_idx, cacode, 4);
    plut = _mm512_i32gather_ps(pcode_idx, cacode, 4);
    llut = _mm512_i32gather_ps(lcode_idx, cacode, 4);

    // Delta step
    ecode_phase_base = _mm512_add_ps(ecode_phase_base, code_step_offset);
    pcode_phase_base = _mm512_add_ps(pcode_phase_base, code_step_offset);
    lcode_phase_base = _mm512_add_ps(lcode_phase_base, code_step_offset);

    // 5- Store values in output buffer
    _mm512_storeu_ps((float *)ecode, elut);
    _mm512_storeu_ps((float *)pcode, plut);
    _mm512_storeu_ps((float *)lcode, llut);

    // 6- Update pointers
    ecode += 16;
    pcode += 16;
    lcode += 16;
  }

  inda = sixteenth_points * 16;

  // generate buffer of output
  for (; inda < blksize; ++inda) {
    baseCode = (inda * codePhaseStep + remCodePhase);
    pCodeIdx = (float)(baseCode) < baseCode ? (baseCode + 1) : baseCode;
    eCodeIdx = (float)(baseCode - earlyLateSpc) < (baseCode - earlyLateSpc)
                   ? (baseCode - earlyLateSpc + 1)
                   : (baseCode - earlyLateSpc);
    lCodeIdx = (float)(baseCode + earlyLateSpc) < (baseCode + earlyLateSpc)
                   ? (baseCode + earlyLateSpc + 1)
                   : (baseCode + earlyLateSpc);

    ecode[inda] = *(cacode + eCodeIdx);
    pcode[inda] = *(cacode + pCodeIdx);
    lcode[inda] = *(cacode + lCodeIdx);
  }
}

/*!
 *  \brief Multiply and accumulates product of two vectors storing the result in
 * an fl32 type
 * \param[in] avector First vector to multiply
 * \param[in] bvector Second vector to multiply
 * \param[in] num_points Number of points in each
 * vector
 */
static inline float avx512_mul_and_acc_fl32(const float *aVector,
                                            const float *bVector,
                                            unsigned int num_points) {

  float returnValue = 0;
  unsigned int number = 0;
  const unsigned int sixteenth_points = num_points / 16;

  const float *aPtr = aVector;
  const float *bPtr = bVector;
  float tempBuffer[16];

  __m512 aVal, bVal, cVal;
  __m512 accumulator = _mm512_setzero_ps();

  for (; number < sixteenth_points; number++) {

    // Load 256-bits of integer data from memory into dst. mem_addr does not
    // need to be aligned on any particular boundary.
    aVal = _mm512_loadu_ps((float *)aPtr);
    bVal = _mm512_loadu_ps((float *)bPtr);

    // TODO: More efficient way to exclude having this intermediate cVal
    // variable??
    cVal = _mm512_mul_ps(aVal, bVal);

    // accumulator += _mm256_mullo_epi16(aVal, bVal);
    accumulator = _mm512_add_ps(accumulator, cVal);

    // Increment pointers
    aPtr += 16;
    bPtr += 16;
  }

  _mm512_storeu_ps((float *)tempBuffer, accumulator);

  returnValue = tempBuffer[0];
  returnValue += tempBuffer[1];
  returnValue += tempBuffer[2];
  returnValue += tempBuffer[3];
  returnValue += tempBuffer[4];
  returnValue += tempBuffer[5];
  returnValue += tempBuffer[6];
  returnValue += tempBuffer[7];
  returnValue += tempBuffer[8];
  returnValue += tempBuffer[9];
  returnValue += tempBuffer[10];
  returnValue += tempBuffer[11];
  returnValue += tempBuffer[12];
  returnValue += tempBuffer[13];
  returnValue += tempBuffer[14];
  returnValue += tempBuffer[15];

  // Perform non SIMD leftover operations
  number = sixteenth_points * 16;
  for (; number < num_points; number++) {
    returnValue += (*aPtr++) * (*bPtr++);
  }
  return returnValue;
}

static inline void avx512_fl32_x2_mul_fl32(float *cVector, const float *aVector,
                                           const float *bVector,
                                           unsigned int num_points) {

  unsigned int number = 0;
  const unsigned int sixteenth_points = num_points / 16;

  float *cPtr = cVector;
  const float *aPtr = aVector;
  const float *bPtr = bVector;

  __m512 aVal, bVal, cVal;

  for (; number < sixteenth_points; number++) {

    // Load 256-bits of integer data from memory into dst. mem_addr does not
    // need to be aligned on any particular boundary.
    aVal = _mm512_loadu_ps((float *)aPtr);
    bVal = _mm512_loadu_ps((float *)bPtr);

    // Multiply packed 16-bit integers in a and b, producing intermediate
    // signed 32-bit integers. Truncate each intermediate integer to the 18
    // most significant bits, round by adding 1, and store bits [16:1] to dst.
    cVal = _mm512_mul_ps(aVal, bVal);

    // Store 256-bits of integer data from a into memory. mem_addr does
    // not need to be aligned on any particular boundary.
    _mm512_storeu_ps((float *)cPtr, cVal);

    // Increment pointers
    aPtr += 16;
    bPtr += 16;
    cPtr += 16;
  }
}

// Multiply and accumulate two vectors of 16bit integers (16i).  Return
// accumulation result as a double
static inline double avx512_mul_and_acc_16i(const short *aVector,
                                            const short *bVector,
                                            unsigned int num_points) {

  int returnValue = 0;
  unsigned int number = 0;
  const unsigned int thirtysecondthPoints = num_points / 32;

  const short *aPtr = aVector;
  const short *bPtr = bVector;
  short tempBuffer[32];

  __m512i aVal, bVal, cVal;
  __m512i accumulator = _mm512_setzero_si512();

  for (; number < thirtysecondthPoints; number++) {

    // Load 512-bits of integer data from memory into dst. mem_addr does not
    // need to be aligned on any particular boundary.
    aVal = _mm512_loadu_si512((__m512i *)aPtr);
    bVal = _mm512_loadu_si512((__m512i *)bPtr);
    // TODO: More efficient way to exclude having this intermediate cVal
    // variable??
    cVal = _mm512_mullo_epi16(aVal, bVal);

    accumulator = _mm512_adds_epi16(accumulator, cVal);

    // Increment pointers
    aPtr += 32;
    bPtr += 32;
  }

  _mm512_storeu_si512((__m512i *)tempBuffer, accumulator);

  returnValue = tempBuffer[0];
  returnValue += tempBuffer[1];
  returnValue += tempBuffer[2];
  returnValue += tempBuffer[3];
  returnValue += tempBuffer[4];
  returnValue += tempBuffer[5];
  returnValue += tempBuffer[6];
  returnValue += tempBuffer[7];
  returnValue += tempBuffer[8];
  returnValue += tempBuffer[9];
  returnValue += tempBuffer[10];
  returnValue += tempBuffer[11];
  returnValue += tempBuffer[12];
  returnValue += tempBuffer[13];
  returnValue += tempBuffer[14];
  returnValue += tempBuffer[15];
  returnValue += tempBuffer[16];
  returnValue += tempBuffer[17];
  returnValue += tempBuffer[18];
  returnValue += tempBuffer[19];
  returnValue += tempBuffer[20];
  returnValue += tempBuffer[21];
  returnValue += tempBuffer[22];
  returnValue += tempBuffer[23];
  returnValue += tempBuffer[24];
  returnValue += tempBuffer[25];
  returnValue += tempBuffer[26];
  returnValue += tempBuffer[27];
  returnValue += tempBuffer[28];
  returnValue += tempBuffer[29];
  returnValue += tempBuffer[30];
  returnValue += tempBuffer[31];

  // Perform non SIMD leftover operations
  number = thirtysecondthPoints * 32;
  for (; number < num_points; number++) {
    returnValue += (*aPtr++) * (*bPtr++);
  }
  return returnValue;
}

/*
// Using this function as reference:
// Multiply and accumulate two vectors of short integers.  Return result in a
double
// TODO: This maxes out at 524272 for some reason??? (i.e. won't return a value
greater than 524272)
// Update: Probably because tempBuffer[] is a short array
static inline double avx2_mul_and_acc_short(const short *aVector, const short
*bVector, unsigned int num_points)
{

  int returnValue = 0;
  unsigned int number = 0;
  const unsigned int sixteenthPoints = num_points / 16;


  const short* aPtr = aVector;
  const short* bPtr = bVector;
  short tempBuffer[16];

  __m256i aVal, bVal, cVal;
  __m256i accumulator = _mm256_setzero_si256();

  for(;number < sixteenthPoints; number++){

    // Load 256-bits of integer data from memory into dst. mem_addr does not
    // need to be aligned on any particular boundary.
    aVal = _mm256_loadu_si256((__m256i*)aPtr);
    bVal = _mm256_loadu_si256((__m256i*)bPtr);

    // TODO: More efficient way to exclude having this intermediate cVal
variable?? cVal = _mm256_mullo_epi16(aVal, bVal);

    //accumulator += _mm256_mullo_epi16(aVal, bVal);
    accumulator = _mm256_adds_epi16(accumulator, cVal);

    // Increment pointers
    aPtr += 16;
    bPtr += 16;

  }

  _mm256_storeu_si256((__m256i*)tempBuffer, accumulator);

  returnValue = tempBuffer[0];
  returnValue += tempBuffer[1];
  returnValue += tempBuffer[2];
  returnValue += tempBuffer[3];
  returnValue += tempBuffer[4];
  returnValue += tempBuffer[5];
  returnValue += tempBuffer[6];
  returnValue += tempBuffer[7];
  returnValue += tempBuffer[8];
  returnValue += tempBuffer[9];
  returnValue += tempBuffer[10];
  returnValue += tempBuffer[11];
  returnValue += tempBuffer[12];
  returnValue += tempBuffer[13];
  returnValue += tempBuffer[14];
  returnValue += tempBuffer[15];

  // Perform non SIMD leftover operations
  number = sixteenthPoints * 16;
  for(;number < num_points; number++){
    returnValue += (*aPtr++) * (*bPtr++);
  }
  return returnValue;
}
*/
